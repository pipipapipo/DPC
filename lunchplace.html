<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Lunch Wheel ‚Äî Pastel RNG</title>
<style>
  :root{
    --bg:#0f172a; --text:#e5e7eb; --muted:#94a3b8;
    --card:#0b1020; --ring:#ffffff22; --btn:#1f2937;
  }
  *{box-sizing:border-box}
  html,body{height:100%}
  body{
    margin:0; font-family: system-ui,-apple-system,Segoe UI,Roboto,Ubuntu,Cantarell,Arial;
    color:var(--text);
    background: radial-gradient(1600px 900px at 20% -10%, #18243b 0%, #0b1220 55%, #070b14 100%), var(--bg);
    display:flex; align-items:center; justify-content:center; padding:18px;
  }

  .wrap{ width:min(960px,100%); display:grid; gap:14px }
  .controls{
    display:flex; gap:10px; align-items:center; justify-content:center; flex-wrap:wrap;
  }
  .btn{
    appearance:none; border:1px solid var(--ring); background:#0e1526; color:var(--text);
    padding:12px 16px; border-radius:12px; cursor:pointer; font-weight:700;
    transition:transform .06s ease, border-color .2s ease, background .2s ease;
    text-decoration:none; display:inline-block;
  }
  .btn.primary{ background: #14b8a6; color:#041016; border-color: transparent; }
  .btn:active{ transform: translateY(1px) }
  .hint{ color:var(--muted); font-size:13px; text-align:center }

  .stage{
    background: linear-gradient(180deg,#0c1424,#0a1020);
    border:1px solid var(--ring); border-radius:18px; padding:20px;
    display:grid; place-items:center; gap:8px;
  }

  /* Wheel */
  .wheel-wrap{ position:relative; display:grid; place-items:center; }
  canvas{ width:min(92vw,520px); height:min(92vw,520px); max-width:520px; max-height:520px; display:block }
  .pointer{
    position:absolute; top:-6px; width:0; height:0; filter:drop-shadow(0 3px 3px rgba(0,0,0,.35));
    border-left:12px solid transparent; border-right:12px solid transparent; border-bottom:22px solid #fde68a;
  }
  .result{ text-align:center; }
  .result h2{ margin:.3rem 0 .1rem; font-size:clamp(20px,3vw,26px) }
  .result .muted{ color:var(--muted) }

  /* Modal */
  .modal{
    position:fixed; inset:0; display:none; place-items:center; z-index:50;
    background:rgba(2,6,23,.65); backdrop-filter: blur(6px);
  }
  .modal.open{ display:grid; }
  .sheet{
    width:min(720px,92vw); background:#0b1220; border:1px solid var(--ring);
    border-radius:14px; padding:16px; box-shadow:0 20px 50px rgba(0,0,0,.45); 
  }
  .sheet h3{ margin:.2rem 0 .4rem }
  .rows{ display:grid; gap:10px; max-height:50vh; overflow:auto; padding-right:4px; }
  .row{
    display:grid; grid-template-columns: 1fr 110px auto; gap:10px; align-items:center;
    background:#0d1629; border:1px solid var(--ring); border-radius:12px; padding:8px;
  }
  .row input{
    width:100%; padding:10px 12px; border-radius:10px; outline:none;
    border:1px solid #ffffff12; background:#0b1324; color:var(--text);
  }
  .row .del{
    background:#2a0e10; color:#fecaca; border:1px solid #ef444455; border-radius:10px; cursor:pointer;
    padding:8px 10px;
  }
  .sheet .actions{ display:flex; justify-content:space-between; gap:8px; margin-top:12px }
  .ghost{ color:var(--muted); text-align:center; padding:8px 0 }
</style>
</head>
<body>
  <main class="wrap">
    <section class="stage">
      <div class="controls">
        <button id="spinBtn" class="btn primary">üé≤ Spin</button>
        <button id="editBtn" class="btn">Edit places</button>
        <a href="index.html" class="btn">‚Üê Return to Menu</a>
      </div>

      <div class="wheel-wrap">
        <div class="pointer" aria-hidden="true"></div>
        <canvas id="wheel" width="1040" height="1040" aria-label="Lunch spinner"></canvas>
      </div>

      <div class="result" id="result" style="display:none">
        <div class="muted">Result</div>
        <h2 id="winnerText">‚Äî</h2>
        <div class="hint" id="countHint"></div>
      </div>

      <p class="hint">Weighted, pastel wheel ‚Ä¢ Lists saved locally</p>
    </section>
  </main>

  <!-- Modal: Manage places -->
  <div id="modal" class="modal" aria-hidden="true">
    <div class="sheet" role="dialog" aria-modal="true" aria-labelledby="modalTitle">
      <h3 id="modalTitle">Edit Lunch Places</h3>
      <div class="rows" id="rows"></div>
      <div class="ghost" id="emptyGhost" style="display:none">No places yet ‚Äî add some below.</div>
      <div class="actions">
        <div style="display:flex; gap:8px">
          <button id="addRow" class="btn">+ Add place</button>
          <button id="clearAll" class="btn">Clear all</button>
        </div>
        <div style="display:flex; gap:8px">
          <button id="closeModal" class="btn">Cancel</button>
          <button id="saveModal" class="btn primary">Save</button>
        </div>
      </div>
    </div>
  </div>

<script>
(() => {
  // ---------- Settings ----------
  const MIN_SLOTS = 30; // ensure at least 30 slices every spin

  // ---------- Storage ----------
  const KEY = 'lunch_pastel_wheel_v2_weights';
  const load = () => { try { return JSON.parse(localStorage.getItem(KEY)) || []; } catch { return []; } };
  const save = (arr) => localStorage.setItem(KEY, JSON.stringify(arr));

  // ---------- Elements ----------
  const canvas = document.getElementById('wheel');
  const ctx = canvas.getContext('2d');
  const DPR = window.devicePixelRatio || 1;
  const spinBtn = document.getElementById('spinBtn');
  const editBtn = document.getElementById('editBtn');
  const resultBox = document.getElementById('result');
  const winnerText = document.getElementById('winnerText');
  const countHint = document.getElementById('countHint');

  const modal = document.getElementById('modal');
  const rowsBox = document.getElementById('rows');
  const emptyGhost = document.getElementById('emptyGhost');
  const addRowBtn = document.getElementById('addRow');
  const clearAllBtn = document.getElementById('clearAll');
  const closeModalBtn = document.getElementById('closeModal');
  const saveModalBtn = document.getElementById('saveModal');

  // ---------- State (with migration from strings) ----------
  let items = load();
  if (!Array.isArray(items) || items.length === 0) {
    items = [
      { name: "Kallang Wave Mall", weight: 3 },
      { name: "Bedok Corner",      weight: 2 },
      { name: "Mr Grumpy",         weight: 1 },
      { name: "Changi Village",    weight: 2 }
    ];
    save(items);
  } else {
    // migrate: strings -> objects with weight=1
    items = items.map(x => typeof x === 'string' ? ({ name: x, weight: 1 }) :
                               ({ name: x.name, weight: Math.max(1, Number(x.weight)||1) }));
    save(items);
  }

  let rotation = 0; // radians
  let spinning = false;
  let pastelSeed = Math.random();

  // Crisp canvas on high DPI + responsive size
  function fitCanvas() {
    const css = Math.min(window.innerWidth * 0.92, 520);
    canvas.style.width = css + 'px';
    canvas.style.height = css + 'px';
    canvas.width = Math.round(css * DPR);
    canvas.height = Math.round(css * DPR);
  }
  fitCanvas(); window.addEventListener('resize', () => { fitCanvas(); draw(); });

  // Pastel color generator (low saturation, high lightness)
  function pastel(i, n, seed=0){
    const h = ( (i/n) * 360 + seed*360 ) % 360;
    const s = 55;  // saturation %
    const l = 72;  // lightness %
    return `hsl(${h} ${s}% ${l}%)`;
  }

  // ---------- Build slots by weight (>= MIN_SLOTS) ----------
  function buildSlots(items, minSlots=MIN_SLOTS){
    const totalWeight = items.reduce((s, it) => s + Math.max(1, Number(it.weight)||1), 0);
    const slotsTarget = Math.max(minSlots, items.length); // ensure at least 30 or #items
    // initial allocation
    const ideals = items.map(it => (Math.max(1, Number(it.weight)||1) / totalWeight) * slotsTarget);
    const base   = ideals.map(x => Math.max(1, Math.floor(x))); // each gets >=1
    let sumBase  = base.reduce((a,b)=>a+b,0);
    let remainder = slotsTarget - sumBase;

    // distribute remainders by largest fractional part
    const fracIdx = ideals.map((v,i)=>({i, frac: v - Math.floor(v)}))
                          .sort((a,b)=>b.frac - a.frac);
    let p = 0;
    while (remainder > 0) {
      base[fracIdx[p % fracIdx.length].i] += 1;
      remainder--;
      p++;
    }
    while (remainder < 0) {
      // take from smallest fractional (reverse)
      const idx = fracIdx[fracIdx.length - 1 - (p % fracIdx.length)].i;
      if (base[idx] > 1) { base[idx] -= 1; remainder++; }
      p++;
      if (p > 10000) break; // safety
    }

    // Construct slots array (contiguous blocks per item)
    const slots = [];
    const spans = []; // {startSlot, count} per item for labeling
    let cursor = 0;
    for (let i=0;i<items.length;i++){
      const count = base[i];
      spans[i] = { start: cursor, count };
      for (let k=0;k<count;k++){ slots.push(i); cursor++; }
    }
    return { slots, spans, slotsCount: slotsTarget };
  }

  // ---------- Draw wheel (small slots, labels once per item) ----------
  function draw(){
    const w = canvas.width, h = canvas.height;
    const cx = w/2, cy = h/2;
    const r  = Math.min(cx, cy) - 10*DPR;
    ctx.clearRect(0,0,w,h);

    if(items.length === 0){
      ctx.fillStyle = '#94a3b8';
      ctx.font = `${16*DPR}px system-ui,sans-serif`;
      ctx.textAlign = 'center';
      ctx.fillText('Add places (Edit) to spin!', cx, cy);
      return;
    }

    const { slots, spans, slotsCount } = buildSlots(items);
    const arc = (Math.PI*2)/slotsCount;
    const baseAngle = rotation - Math.PI/2;

    // draw slots (thin separators give the "many slices" look)
    for (let s=0; s<slotsCount; s++){
      const itemIdx = slots[s];
      const start = baseAngle + s*arc;
      const end   = start + arc;

      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,r,start,end);
      ctx.closePath();
      ctx.fillStyle = pastel(itemIdx, items.length, pastelSeed);
      ctx.fill();
    }

    // (optional) separators per slot
    ctx.strokeStyle = 'rgba(255,255,255,.12)';
    ctx.lineWidth = 1*DPR;
    for (let s=0; s<slotsCount; s++){
      const start = baseAngle + s*arc;
      ctx.beginPath();
      ctx.moveTo(cx,cy);
      ctx.arc(cx,cy,r, start, start);
      ctx.stroke();
    }

    // labels: one per item at the center of its span
    for (let i=0;i<items.length;i++){
      const span = spans[i];
      const midSlot = span.start + span.count/2;
      const mid = baseAngle + midSlot * arc;

      ctx.save();
      ctx.translate(cx,cy);
      ctx.rotate(mid);
      ctx.textAlign = 'right';
      ctx.fillStyle = '#0b1020';
      ctx.font = `bold ${Math.max(12, Math.min(18, r/10))*DPR}px system-ui,sans-serif`;
      const text = items[i].name;
      const max = 26;
      const label = text.length>max ? text.slice(0,max-1)+'‚Ä¶' : text;
      ctx.fillText(label, r - 14*DPR, 6*DPR);
      ctx.restore();
    }

    // hub
    ctx.beginPath();
    ctx.arc(cx,cy, 38*DPR, 0, Math.PI*2);
    ctx.fillStyle = '#0b1020';
    ctx.fill();
    ctx.lineWidth = 2*DPR;
    ctx.strokeStyle = 'rgba(255,255,255,.18)';
    ctx.stroke();
  }

  // weighted random via slots
  function pickSlot(slotsCount){ return Math.floor(Math.random()*slotsCount); }

  // Spin logic (longer for drama)
  function spin(){
    if (spinning || items.length===0) return;
    spinning = true; spinBtn.disabled = true; resultBox.style.display='none';

    const built = buildSlots(items);
    const { slots, spans, slotsCount } = built;
    const arc = (Math.PI*2)/slotsCount;

    const pickedSlot = pickSlot(slotsCount);
    const winnerIdx  = slots[pickedSlot]; // item index

    // spin so the center of the picked slot lands at 12 o'clock
    const rounds = 8 + Math.floor(Math.random()*5);       // 8‚Äì12 full rotations
    const duration = 5000 + Math.random()*2000;           // 5‚Äì7s
    const slotCenterAngle = (pickedSlot + 0.5) * arc;
    const baseAngleNow = rotation % (Math.PI*2);
    const targetMidAtTop = 0; // relative to rotation offset below

    // We want: (rotation - PI/2 + slotCenterAngle) % TAU === -PI/2 (== 0 in our relative space)
    // So delta = (2œÄ - slotCenterAngle)
    const deltaToTop = (2*Math.PI - slotCenterAngle) % (2*Math.PI);
    const start = rotation;
    const target = start + rounds * (Math.PI*2) + deltaToTop;
    const totalDelta = target - start;

    const t0 = performance.now();
    (function anim(now){
      const t = Math.min(1, (now - t0)/duration);
      const ease = 1 - Math.pow(1 - t, 4); // quartic-out for heavier slow-down
      rotation = start + totalDelta * ease;
      draw();
      if (t < 1) { requestAnimationFrame(anim); }
      else {
        spinning = false; spinBtn.disabled = false;
        showWinner(winnerIdx, built);
      }
    })(t0);
  }

  function showWinner(itemIdx, built){
    winnerText.textContent = items[itemIdx].name;
    countHint.textContent = `${built.slotsCount} slices ‚Ä¢ ${items.length} places`;
    resultBox.style.display = 'block';
  }

  // ---------- Modal helpers (name + weight) ----------
  function openModal(){
    rowsBox.innerHTML = '';
    if (items.length === 0) emptyGhost.style.display = 'block'; else emptyGhost.style.display = 'none';
    items.forEach(it => addRow(it));
    modal.classList.add('open'); modal.setAttribute('aria-hidden','false');
  }
  function closeModal(){
    modal.classList.remove('open'); modal.setAttribute('aria-hidden','true');
  }
  function addRow(value={name:'', weight:1}){
    const row = document.createElement('div');
    row.className = 'row';

    const nameInput = document.createElement('input');
    nameInput.type = 'text';
    nameInput.placeholder = 'Place name';
    nameInput.value = value.name || '';

    const weightInput = document.createElement('input');
    weightInput.type = 'number';
    weightInput.min = '1';
    weightInput.step = '1';
    weightInput.value = String(Math.max(1, Number(value.weight)||1));
    weightInput.title = 'Weight (chance / relative slice size)';

    const del = document.createElement('button');
    del.className = 'del';
    del.type = 'button';
    del.textContent = 'Remove';
    del.onclick = () => {
      row.remove();
      if (rowsBox.children.length === 0) emptyGhost.style.display = 'block';
    };

    row.append(nameInput, weightInput, del);
    rowsBox.appendChild(row);
    emptyGhost.style.display = 'none';
    nameInput.focus();
  }
  function saveRows(){
    const rows = Array.from(rowsBox.querySelectorAll('.row'));
    const next = rows.map(row => {
      const [nameInput, weightInput] = row.querySelectorAll('input');
      const name = nameInput.value.trim();
      const weight = Math.max(1, Number(weightInput.value)||1);
      return name ? { name, weight } : null;
    }).filter(Boolean);

    items = next;
    save(items);
    draw();
  }

  // Events
  spinBtn.addEventListener('click', spin);
  editBtn.addEventListener('click', openModal);
  addRowBtn.addEventListener('click', () => addRow({name:'', weight:1}));
  clearAllBtn.addEventListener('click', () => { rowsBox.innerHTML=''; emptyGhost.style.display='block'; });
  closeModalBtn.addEventListener('click', closeModal);
  saveModalBtn.addEventListener('click', () => { saveRows(); closeModal(); });
  modal.addEventListener('click', (e)=>{ if(e.target === modal) closeModal(); });
  window.addEventListener('keydown', (e)=>{ if(e.key==='Escape') closeModal(); });

  // Init
  draw();
})();
</script>
</body>
</html>
